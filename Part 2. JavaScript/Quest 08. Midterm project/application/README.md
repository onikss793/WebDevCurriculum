# POS 어플리케이션

## 클래스 목록

1. [POS](#POS)
2. [MenuBoard](#MenuBoard)
3. [Product](#Product)
4. [Cart](#Cart)
5. [Calculator](#Calculator)
6. [Bill](#Bill)
7. [Payment](#Payment)
8. [Alert](#Alert)
9. [Data](#Data)
10. [Template](#Template)

## 클래스 역할

### POS

어플리케이션에 필요한 객체를 생성한다.  
아래의 "정보 교환" 메소드를 갖는다.

    1. MenuBoard에서 선택한 Product를 Cart로
    2. Cart에 담긴 정보를 Bill로
    3. Calculator에서 계산한 값을 Bill로

결제 기능은 없기 때문에 계산해야할 금액과 지불한 금액이 같다면 `결제`를 한 것으로 생각한다.  
`결제 완료 (현금 수납함의 개폐, 카드 승인 등)`를 알 수 없기 때문에 2초 간 결제 완료 모달을 띄운 뒤 없앤다.

### MenuBoard

POS에서 메뉴판의 역할을 갖는다.  
Product를 메뉴판에 생성한다.  
각각의 메뉴에 Click 이벤트를 부여한다.

### Product

상품 객체이다.  
상품명과 가격을 상태로 갖는다.

### Cart

POS 객체로부터 전달받은 Menu를 토대로 Cart에 하나의 Row로 추가한다.  
각각의 상품명을 Key로, Product 객체를 Value로 갖는 `product{}` 상태를 갖는다.  
추가된 Row의 Element를 담고 있는 `rowElements[]` 상태를 갖는다.

### Calculator

계산기 객체이다.  
각각의 계산기 패드에 Click 이벤트를 부여한다.  
[입력] 패드를 누르면 결제를 진행하는 것으로 간주한다.

### Bill

결제 정보 옵션을 `options`라는 상태로 갖는다.  
결제 정보들`(amount, total, discount[고려X], toPay, paid, change)`을 상태로 갖는다.  
Cart에 새로운 Product 객체가 들어올 때마다 결제 정보를 갱신한다.  
갱신 과정에서 지불해야 할 금액과 지불한 금액이 갖다면 POS의 `결제 완료` 메소드를 실행한다.

### Payment

현금, 카드, 취소 3개의 상태를 나타낸다.  
카드를 선택할 경우, 기타 기능 없이 일시불로 전액 결제하는 것으로 간주한다.  
따라서 기본 상태는 항상 현금을 유지하며, 계산기에 값을 입력하는 것으로 현금 결제를 진행한다.

### Alert

결제 완료를 알리는 모달창의 역할을 한다.  
2초 뒤에 사라진다.

### Data

메뉴판에 들어갈 Product의 정보를 갖고 있다.  
POS 기기에서 결제 완료 후, 해당 결제 내역을 저장시키는 객체이다.

### Template

HTML 파일에 있는 여러 개의 `<template>`을 가리킨다.  
해당 객체의 메소드를 사용해 반복되는 template 생성 함수를 대체한다.

---

## Feedback

객체 간의 관계가 느슨하다는 것은 객체가 서로의 내부를 들여다보는 일을 하지 않아야 한다는 것을 의미한다.

객체끼리의 통신 - DOM 간의 통신이 있는데, 가능하면 DOM 간의 통신을 이용하는 것이 바람직하다. 왜냐하면 객체 간의 결속력을 떨어뜨릴 수 있기 때문에
POS 객체 내부의 메소드를 다른 객체의 이벤트 헨들러의 인자로 넘기는 방식을 사용하고 있는데, DOM 간의 통신을 이용하거나 constructor 함수가 호출될 때 인자로 넘겨주는 방식을 쓰는 것이 더 좋다.

메소드 체이닝을 자주 사용하게 되면 나중에 콜백, 프로미스에 대처하기 힘들다.

만약 어떤 메소드가 다른 객체의 데이터를 받아야 한다면, 다른 겍체 안을 들여다보는 방식을 사용하지 말고, 다른 객체의 메소드를 통해 데이터를 받는 방식을 사용하는 것이 객체 간의 결속력을 떨어뜨릴 수 있다.

만약 복잡한 할인 정책이 들어가게 된다면 어떻게 설계를 할 수 있을까?

    예시

    아메리카노 1잔 + 라떼 1잔 => 아포가토 1천원 할인
    드립 커피 1잔 => 에스프레소 공짜(3천원 할인)

점점 더 복잡한 할인 정책이 들어갈 수 있으므로, Discount 라는 클래스로 만드는 것이 더 좋을 것이다.

Discount의 Instance를 어디서 생성해서 어디서 관리할 것인가는 어떻게 설계하느냐에 따라 달라질 수 있을 것이다.

현재 Cart에는 매개 변수로 Product 객체를 전부 갖고 있다. Discount를 적용시키게 되면서 이 설계를 바꿔야 할 수도 있는데, 예를 들어 정가만 존재하는 프로덕트 정가들의 배열과 같은 형식의 매개 변수를 활용할 수도 있을 것이다.

그렇게 되면 Cart에는 다른 rule이 있어서 실제 정가에 할인이 반영된 `실제 계산이 될 가격`을 따로 가지고 있어야 한다.

Cart에 보면 메소드 안에 map과 reduce로 복잡한 함수가 들어가는데 이것을 별도의 메소드로 리펙토링 하는 것이 낫다.

메소드 하나가 너무 지리해지면 안 된다.

If, else => 객체 지향에서 지양한다.

<오브젝트>라는 책의 앞부분을 읽어보면 힌트를 얻을 수 있다. 리펙토링 생각해보기.
